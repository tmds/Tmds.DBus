using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Xml.Linq;
using Tmds.DBus.Protocol;
using Microsoft.Win32.SafeHandles;

namespace Tmds.DBus.Tool
{
    enum Accessibility
    {
        NotApplicable,
        Public,
        Internal,
        Private,
        Protected
    }

    class ProtocolGeneratorSettings
    {
        public string Namespace { get; set; } = "DBus";
        public string ServiceName { get; set; }
        public Accessibility TypesAccessModifier = Accessibility.NotApplicable;
        public string? GeneratorDescription { get; set; }
    }

    class ProtocolGenerator : IGenerator
    {
        private readonly ProtocolGeneratorSettings _settings;
        private readonly StringBuilder _sb = new();
        private readonly Dictionary<string, (bool, Argument[])> _messageReadMethods = new();
        private readonly Dictionary<string, string> _typeReadMethods = new();
        private readonly Dictionary<string, string> _typeWriteMethods = new();
        private int _indentation = 0;

        public ProtocolGenerator(ProtocolGeneratorSettings settings)
        {
            _settings = settings;
        }

        private void StartBlock()
        {
            AppendLine("{");
            _indentation++;
        }

        private void EndBlock()
        {
            _indentation--;
            AppendLine("}");
        }

        private void AppendLine(string line)
        {
            if (line.Length == 0)
            {
                return;
            }
            if (line.Length != 0)
            {
                _sb.Append(' ', _indentation * 4);
            }
            _sb.AppendLine(line);
        }

        public string Generate(IEnumerable<InterfaceDescription> interfaceDescriptions)
        {
            _sb.Clear();
            if (!string.IsNullOrEmpty(_settings.GeneratorDescription))
            {
                AppendLine($"// Generated by {_settings.GeneratorDescription}");
            }
            AppendLine("// <auto-generated/>");
            AppendLine("#nullable enable");

            AppendLine($"namespace {_settings.Namespace}");
            StartBlock();

            AppendLine($"using System;");
            AppendLine($"using Tmds.DBus.Protocol;");
            AppendLine($"using System.Collections.Generic;");
            AppendLine("using System.Threading.Tasks;");

            foreach (var interf in interfaceDescriptions)
            {
                try
                {
                    AppendInterface(interf.Name, interf.InterfaceXml);
                }
                catch (Exception ex)
                {
                    throw new InterfaceGenerationException(interf, ex);
                }
            }

            AppendServiceClass(interfaceDescriptions);
            AppendReaderClass();
            AppendMessageWriterExtensionsClass();

            EndBlock();

            return _sb.ToString();
        }

        private void AppendServiceClass(IEnumerable<InterfaceDescription> interfaceDescriptions)
        {
            AppendLine("static partial class ObjectFactory");
            StartBlock();
            foreach (var interf in interfaceDescriptions)
            {
                string interfaceName = interf.Name;
                AppendLine($"public static {interfaceName} Create{interfaceName}(this DBusService service, ObjectPath path) => new {interfaceName}(service.Connection, service.Name, path);");
            }
            EndBlock();
        }

        private void AppendReaderClass()
        {
            AppendLine("file static class MessageReader");
            StartBlock();

            foreach (var readMethod in _messageReadMethods)
            {
                AppendReadMessageMethod(readMethod.Key, readMethod.Value.Item1, readMethod.Value.Item2);
            }

            foreach (var readMethod in _typeReadMethods)
            {
                AppendReadTypeMethod(readMethod.Key, readMethod.Value);
            }

            EndBlock();
        }

        private void AppendMessageWriterExtensionsClass()
        {
            AppendLine("file static class MessageWriterExtensions");
            StartBlock();

            foreach (var writeMethod in _typeWriteMethods)
            {
                AppendWriteTypeMethod(writeMethod.Key, writeMethod.Value);
            }

            EndBlock();
        }

        private void AppendReadTypeMethod(string method, string signature)
        {
            string dotnetReturnType = GetDotnetReadType(signature);
            AppendLine($"public static {dotnetReturnType} {method}(this ref Reader reader)");
            StartBlock();
            SignatureReader reader = new SignatureReader(Encoding.UTF8.GetBytes(signature));
            if (reader.TryRead(out DBusType type, out ReadOnlySpan<byte> innerSignature))
            {
                reader = new SignatureReader(innerSignature);
                if (type == DBusType.Array)
                {
                    if (!reader.TryRead(out DBusType itemType, out ReadOnlySpan<byte> itemInnerSignature))
                    {
                        ThrowInvalidSignature(signature);
                    }
                    if (itemType == DBusType.DictEntry)
                    {
                        reader = new SignatureReader(itemInnerSignature);
                        if (!reader.TryRead(out DBusType keyType, out ReadOnlySpan<byte> keyInnerSignature))
                        {
                            ThrowInvalidSignature(signature);
                        }
                        if (!reader.TryRead(out DBusType valueType, out ReadOnlySpan<byte> valueInnerSignature))
                        {
                            ThrowInvalidSignature(signature);
                        }

                        string dotnetKeyType = GetDotnetReadType(keyType, keyInnerSignature);
                        string dotnetValueType = GetDotnetReadType(valueType, valueInnerSignature);
                        string keyTypeSignature = GetSignature(keyType, keyInnerSignature);
                        string valueTypeSignature = GetSignature(valueType, valueInnerSignature);

                        AppendLine($"Dictionary<{dotnetKeyType}, {dotnetValueType}> dictionary = new();");
                        AppendLine($"ArrayEnd dictEnd = reader.ReadDictionaryStart();");

                        AppendLine($"while (reader.HasNext(dictEnd))");
                        StartBlock();
                        AppendLine($"var key = {CallReadArgumentType(keyTypeSignature)};");
                        AppendLine($"var value = {CallReadArgumentType(valueTypeSignature)};");
                        AppendLine($"dictionary[key] = value;");
                        EndBlock();

                        AppendLine($"return dictionary;");
                    }
                    else
                    {
                        string dotnetItemType = GetDotnetReadType(itemType, itemInnerSignature);

                        AppendLine($"List<{dotnetItemType}> list = new();");
                        AppendLine($"ArrayEnd arrayEnd = reader.ReadArrayStart({GetDBusTypeEnumValue(itemType)});");

                        AppendLine($"while (reader.HasNext(arrayEnd))");
                        StartBlock();
                        AppendLine($"list.Add({CallReadArgumentType(Encoding.UTF8.GetString(innerSignature))});");
                        EndBlock();

                        AppendLine($"return list.ToArray();");
                    }
                }
                else if (type == DBusType.Struct)
                {
                    StringBuilder sb = new();
                    sb.Append("return (");
                    bool first = true;
                    while (reader.TryRead(out DBusType fieldType, out ReadOnlySpan<byte> fieldInnerSignature))
                    {
                        if (!first)
                        {
                            sb.Append(", ");
                        }
                        first = false;
                        sb.Append(CallReadArgumentType(GetSignature(fieldType, fieldInnerSignature)));
                    }
                    sb.Append(");");
                    AppendLine(sb.ToString());
                }
                else
                {
                    ThrowInvalidSignature(signature);
                }
            }
            EndBlock();
        }

        private void AppendWriteTypeMethod(string method, string signature)
        {
            string dotnetArgType = GetDotnetWriteType(signature);
            AppendLine($"public static void {method}(this ref MessageWriter writer, {dotnetArgType} value)");
            StartBlock();
            SignatureReader reader = new SignatureReader(Encoding.UTF8.GetBytes(signature));
            if (reader.TryRead(out DBusType type, out ReadOnlySpan<byte> innerSignature))
            {
                reader = new SignatureReader(innerSignature);
                if (type == DBusType.Array)
                {
                    if (!reader.TryRead(out DBusType itemType, out ReadOnlySpan<byte> itemInnerSignature))
                    {
                        ThrowInvalidSignature(signature);
                    }
                    if (itemType == DBusType.DictEntry)
                    {
                        reader = new SignatureReader(itemInnerSignature);
                        if (!reader.TryRead(out DBusType keyType, out ReadOnlySpan<byte> keyInnerSignature))
                        {
                            ThrowInvalidSignature(signature);
                        }
                        if (!reader.TryRead(out DBusType valueType, out ReadOnlySpan<byte> valueInnerSignature))
                        {
                            ThrowInvalidSignature(signature);
                        }

                        string keyTypeSignature = GetSignature(keyType, keyInnerSignature);
                        string valueTypeSignature = GetSignature(valueType, valueInnerSignature);

                        AppendLine($"ArrayStart arrayStart = writer.WriteDictionaryStart();");
                        AppendLine($"foreach (var item in value)");
                        StartBlock();
                        AppendLine($"writer.WriteDictionaryEntryStart();");
                        AppendLine($"{CallWriteArgumentType(keyTypeSignature, "item.Key")};");
                        AppendLine($"{CallWriteArgumentType(valueTypeSignature, "item.Value")};");
                        EndBlock();
                        AppendLine($"writer.WriteDictionaryEnd(arrayStart);");
                    }
                    else
                    {
                        string dotnetItemSignature = GetSignature(itemType, itemInnerSignature);

                        AppendLine($"ArrayStart arrayStart = writer.WriteArrayStart({GetDBusTypeEnumValue(itemType)});");
                        AppendLine($"foreach (var item in value)");
                        StartBlock();
                        AppendLine($"{CallWriteArgumentType(dotnetItemSignature, "item")};");
                        EndBlock();
                        AppendLine($"writer.WriteArrayEnd(arrayStart);");
                    }
                }
                else if (type == DBusType.Struct)
                {
                    AppendLine($"writer.WriteStructureStart();");
                    int i = 1;
                    while (reader.TryRead(out DBusType fieldType, out ReadOnlySpan<byte> fieldInnerSignature))
                    {
                        string fieldSignature = GetSignature(fieldType, fieldInnerSignature);
                        string parameterName = i < 8 ? $"value.Item{i}" : $"value.Rest.Item{1 + (i % 8)}";
                        AppendLine($"{CallWriteArgumentType(fieldSignature, parameterName)};");
                        i++;
                    }
                }
                else
                {
                    ThrowInvalidSignature(signature);
                }
            }
            EndBlock();
        }

        private void AppendInterface(string name, XElement interfaceXml)
        {
            var readableProperties = ReadableProperties(interfaceXml).Select(ToArgument).ToArray();
            var writablePropertiesArray = WritableProperties(interfaceXml).Select(ToArgument).ToArray();
            var writableProperties = writablePropertiesArray.AsEnumerable();

            string propertiesClassName = $"{name}Properties";
            string propertyEnumName = $"{name}Property";
            string propertiesInterfaceName = $"I{propertiesClassName}";

            if (readableProperties.Any())
            {
                // Validate property count
                if (readableProperties.Length > 64)
                {
                    throw new NotSupportedException($"Interface '{name}' has {readableProperties.Length} readable properties, but the maximum supported is 64.");
                }

                AppendLine($"interface {propertiesInterfaceName}");
                StartBlock();
                foreach (var property in readableProperties)
                {
                    AppendLine($"{GetNullableType(property.DotnetReadType)} {property.NameUpper} {{ get; }}");
                }
                foreach (var property in readableProperties)
                {
                    AppendLine($"bool Has{property.NameUpper}Changed {{ get; }}");
                }
                AppendLine("bool AreAllPropertiesSet();");
                AppendLine($"{propertiesClassName} EnsureAllPropertiesSet();");
                EndBlock();

                AppendLine($"sealed class {propertiesClassName} : {propertiesInterfaceName}");
                StartBlock();

                // Choose uint or ulong based on number of properties
                string flagType = readableProperties.Length <= 32 ? "uint" : "ulong";
                string one = readableProperties.Length <= 32 ? "1U" : "1UL";

                // Calculate all properties set value
                string allSetValue;
                if (readableProperties.Length <= 32)
                {
                    uint value = readableProperties.Length == 32 ? uint.MaxValue : (1U << readableProperties.Length) - 1;
                    allSetValue = $"0x{value:X}U";
                }
                else
                {
                    ulong value = readableProperties.Length == 64 ? ulong.MaxValue : (1UL << readableProperties.Length) - 1;
                    allSetValue = $"0x{value:X}UL";
                }

                // Generate flags fields
                AppendLine($"private {flagType} __set;");
                AppendLine($"private {flagType} __invalidated;");
                AppendLine($"private const {flagType} PropertiesAllSet = {allSetValue}; // {readableProperties.Length} properties");

                // Generate static Flag method
                AppendLine($"private static {flagType} Flag({propertyEnumName} property) => property == 0 ? 0 : {one} << ((int)property - 1);");

                // Generate constructors
                AppendLine($"public {propertiesClassName}() {{ }}");
                AppendLine("#nullable disable");
                AppendLine("[System.Diagnostics.CodeAnalysis.SetsRequiredMembers]");
                AppendLine($"private {propertiesClassName}(bool _) {{ }}");
                AppendLine("#nullable enable");

                // Generate EnsureSet helper method
                AppendLine($"private void EnsureSet({propertyEnumName} property)");
                StartBlock();
                AppendLine("if (!HasFlag(__set, property))");
                StartBlock();
                AppendLine("throw new InvalidOperationException(\"Property is not set.\");");
                EndBlock();
                EndBlock();

                // Generate properties
                foreach (var property in readableProperties)
                {
                    AppendLine($"private {property.DotnetReadType} {property.UnderscoreNameLower} = default!;");
                    AppendLine($"public required {property.DotnetReadType} {property.NameUpper}");
                    StartBlock();
                    AppendLine($"get {{ EnsureSet({propertyEnumName}.{property.NameUpper}); return {property.UnderscoreNameLower}; }}");
                    AppendLine($"set {{ {property.UnderscoreNameLower} = value; __set |= Flag({propertyEnumName}.{property.NameUpper}); }}");
                    EndBlock();
                }

                foreach (var property in readableProperties)
                {
                    string nullableType = GetNullableType(property.DotnetReadType);
                    AppendLine($"{nullableType} {propertiesInterfaceName}.{property.NameUpper}");
                    _indentation++;
                    AppendLine($"=> IsSet({propertyEnumName}.{property.NameUpper}) ? {property.UnderscoreNameLower} : null;");
                    _indentation--;
                }

                foreach (var property in readableProperties)
                {
                    AppendLine($"bool {propertiesInterfaceName}.Has{property.NameUpper}Changed");
                    _indentation++;
                    AppendLine($"=> IsSet({propertyEnumName}.{property.NameUpper}) || IsInvalidated({propertyEnumName}.{property.NameUpper});");
                    _indentation--;
                }

                AppendLine($"{propertiesClassName} {propertiesInterfaceName}.EnsureAllPropertiesSet()");
                StartBlock();
                AppendLine("EnsureAllPropertiesSet();");
                AppendLine("return this;");
                EndBlock();

                AppendLine($"public static {propertiesClassName} CreateUninitialized() => new {propertiesClassName}(false);");

                AppendLine($"private bool HasFlag({flagType} flags, {propertyEnumName} property)");
                _indentation++;
                AppendLine($"=> property != 0 && (flags & Flag(property)) != 0;");
                _indentation--;

                AppendLine($"[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]");
                AppendLine($"private static {propertyEnumName} ParsePropertyName(string propertyName)");
                StartBlock();
                AppendLine("return propertyName switch");
                StartBlock();
                foreach (var property in readableProperties)
                {
                    AppendLine($"\"{property.Name}\" => {propertyEnumName}.{property.NameUpper},");
                }
                AppendLine("_ => 0");
                _indentation--;
                AppendLine("};");
                EndBlock();

                AppendLine($"private bool IsSet({propertyEnumName} property) => HasFlag(__set, property);");
                AppendLine($"private bool IsInvalidated({propertyEnumName} property) => HasFlag(__invalidated, property);");

                AppendLine($"private void SetInvalidated({propertyEnumName} property)");
                StartBlock();
                AppendLine("if (property != 0)");
                StartBlock();
                AppendLine("__invalidated |= Flag(property);");
                EndBlock();
                EndBlock();
                AppendLine($"[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]");
                AppendLine($"public void SetInvalidated(string propertyName) => SetInvalidated(ParsePropertyName(propertyName));");

                AppendLine($"public bool AreAllPropertiesSet() => __set == PropertiesAllSet;");

                AppendLine("public void EnsureAllPropertiesSet()");
                StartBlock();
                AppendLine("if (!AreAllPropertiesSet())");
                StartBlock();
                AppendLine("throw new DBusUnexpectedValueException($\"Not all properties have been set (0x{__set:x}).\");");
                EndBlock();
                EndBlock();

                AppendLine($"public static {propertiesInterfaceName} ReadFrom(ref Reader reader, bool withInvalidated)");
                StartBlock();
                AppendLine($"var props = CreateUninitialized();");
                AppendLine("ArrayEnd arrayEnd = reader.ReadArrayStart(DBusType.Struct);");
                AppendLine("while (reader.HasNext(arrayEnd))");
                StartBlock();

                AppendLine("var property = reader.ReadString();");
                AppendLine("switch (property)");
                StartBlock();

                foreach (var property in readableProperties)
                {
                    AppendLine($"case \"{property.Name}\":");
                    _indentation++;
                    AppendLine($"reader.ReadSignature(\"{property.Signature}\"u8);");
                    AppendLine($"props.{property.NameUpper} = {CallReadArgumentType(property.Signature)};");
                    AppendLine("break;");
                    _indentation--;
                }
                AppendLine("default:");
                _indentation++;
                AppendLine($"reader.ReadVariantValue();");
                AppendLine("break;");
                _indentation--;

                EndBlock(); // switch

                EndBlock(); // while

                // Read invalidated properties if requested
                AppendLine("if (withInvalidated)");
                StartBlock();
                AppendLine("ArrayEnd invalidatedEnd = reader.ReadArrayStart(DBusType.String);");
                AppendLine("while (reader.HasNext(invalidatedEnd))");
                StartBlock();
                AppendLine("var propertyName = reader.ReadString();");
                AppendLine("props.__invalidated |= propertyName switch");
                StartBlock();
                foreach (var property in readableProperties)
                {
                    AppendLine($"\"{property.Name}\" => Flag({propertyEnumName}.{property.NameUpper}),");
                }
                AppendLine("_ => 0");
                _indentation--;
                AppendLine("};");
                EndBlock(); // while
                EndBlock(); // if

                AppendLine("return props;");
                EndBlock();

                AppendLine($"private enum {propertyEnumName}");
                StartBlock();
                AppendLine("UnknownProperty = 0,");
                for (int i = 0; i < readableProperties.Length; i++)
                {
                    var property = readableProperties[i];
                    AppendLine($"{property.NameUpper} = {i + 1}{(i < readableProperties.Length - 1 ? "," : "")}");
                }
                EndBlock();

                EndBlock();
            }

            AppendLine($"sealed partial class {name} : Tmds.DBus.Protocol.DBusObject");
            StartBlock();

            string interfaceName = (string)interfaceXml.Attribute("name");
            AppendLine($"public const string DBusInterfaceName = \"{interfaceName}\";");

            AppendLine($"public {name}(Tmds.DBus.Protocol.DBusConnection connection, string destination, ObjectPath path)");
            AppendLine("    : base(connection, destination, path)");
            AppendLine("{ }");

            foreach (var method in interfaceXml.Elements("method"))
            {
                AppendMethod(method);
            }

            foreach (var signal in interfaceXml.Elements("signal"))
            {
                AppendSignal(name, signal);
            }

            foreach (var property in writableProperties)
            {
                AppendPropertySetMethod(property);
            }

            if (readableProperties.Any())
            {
                foreach (var property in readableProperties)
                {
                    AppendLine($"public Task<{property.DotnetReadType}> Get{property.NameUpper}Async()");
                    _indentation++;
                    string readMessageName = GetReadMessageMethodName(new[] { property }, variant: true);
                    AppendLine($"=> Connection.CallMethodAsync(CreateGetPropertyMessage(\"{property.Name}\"), (Message m, object? s) => MessageReader.{readMessageName}(m), this);");
                    _indentation--;
                }

                // GetPropertiesAsync
                AppendLine($"public async Task<{propertiesInterfaceName}> GetPropertiesAsync()");
                StartBlock();
                AppendLine($"var props = await Connection.CallMethodAsync(CreateGetAllPropertiesMessage(), (Message m, object? s) => ReadMessage(m), this).ConfigureAwait(false);");
                AppendLine("props.EnsureAllPropertiesSet();");
                AppendLine("return props;");

                AppendLine($"static {propertiesInterfaceName} ReadMessage(Message message)");
                StartBlock();
                AppendLine("var reader = message.GetBodyReader();");
                AppendLine($"return {propertiesClassName}.ReadFrom(ref reader, withInvalidated: false);");
                EndBlock(); // ReadMessage

                EndBlock(); // method

                // WatchPropertiesChangedAsync
                AppendLine($"public ValueTask<IDisposable> WatchPropertiesChangedAsync(Action<Exception?, {propertiesInterfaceName}> handler, bool emitOnCapturedContext = true, ObserverFlags flags = ObserverFlags.None)");
                StartBlock();
                AppendLine($"return Connection.WatchPropertiesChangedAsync(Destination, Path, DBusInterfaceName, (Message m, object? s) => ReadMessage(m), handler, this, emitOnCapturedContext, flags);");
                AppendLine($"static {propertiesInterfaceName} ReadMessage(Message message)");
                StartBlock();
                AppendLine("var reader = message.GetBodyReader();");
                AppendLine("reader.ReadString(); // interface");
                AppendLine($"return {propertiesClassName}.ReadFrom(ref reader, withInvalidated: true);");
                EndBlock();
                EndBlock();

                // CreateGetPropertyMessage helper
                AppendLine("private MessageBuffer CreateGetPropertyMessage(string property)");
                StartBlock();
                AppendLine("var writer = Connection.GetMessageWriter();");
                AppendLine("writer.WriteMethodCallHeader(");
                AppendLine("    destination: Destination,");
                AppendLine("    path: Path,");
                AppendLine("    @interface: \"org.freedesktop.DBus.Properties\",");
                AppendLine("    signature: \"ss\",");
                AppendLine("    member: \"Get\");");
                AppendLine("writer.WriteString(DBusInterfaceName);");
                AppendLine("writer.WriteString(property);");
                AppendLine("return writer.CreateMessage();");
                EndBlock();

                // CreateGetAllPropertiesMessage helper
                AppendLine("private MessageBuffer CreateGetAllPropertiesMessage()");
                StartBlock();
                AppendLine("var writer = Connection.GetMessageWriter();");
                AppendLine("writer.WriteMethodCallHeader(");
                AppendLine("    destination: Destination,");
                AppendLine("    path: Path,");
                AppendLine("    @interface: \"org.freedesktop.DBus.Properties\",");
                AppendLine("    signature: \"s\",");
                AppendLine("    member: \"GetAll\");");
                AppendLine("writer.WriteString(DBusInterfaceName);");
                AppendLine("return writer.CreateMessage();");
                EndBlock();
            }

            EndBlock();
        }

        private void AppendPropertySetMethod(Argument property)
        {
            string methodName = $"Set{property.NameUpper}Async";
            AppendLine($"public Task {methodName}({property.DotnetWriteType} value)");
            StartBlock();
            AppendLine($"return Connection.CallMethodAsync(CreateMessage());");
            AppendLine("MessageBuffer CreateMessage()");
            StartBlock();
            AppendLine("var writer = Connection.GetMessageWriter();");
            AppendLine("writer.WriteMethodCallHeader(");
            AppendLine("    destination: Destination,");
            AppendLine("    path: Path,");
            AppendLine("    @interface: \"org.freedesktop.DBus.Properties\",");
            AppendLine("    signature: \"ssv\",");
            AppendLine("    member: \"Set\");");
            AppendLine("writer.WriteString(DBusInterfaceName);");
            AppendLine($"writer.WriteString(\"{property.Name}\");");
            AppendLine($"writer.WriteSignature(\"{property.Signature}\");");
            AppendLine($"{CallWriteArgumentType(property.Signature, "value")};");
            AppendLine("return writer.CreateMessage();");
            EndBlock();
            EndBlock();
        }

        private IEnumerable<XElement> Properties(XElement interfaceXml)
            => interfaceXml.Elements("property");

        private IEnumerable<XElement> ReadableProperties(XElement interfaceXml)
            => Properties(interfaceXml).Where(p => p.Attribute("access").Value.StartsWith("read", StringComparison.Ordinal));

        private IEnumerable<XElement> WritableProperties(XElement interfaceXml)
            => Properties(interfaceXml).Where(p => p.Attribute("access").Value.EndsWith("write", StringComparison.Ordinal));

        private void AppendSignal(string className, XElement signalXml)
        {
            string dbusSignalName = (string)signalXml.Attribute("name");

            var args = signalXml.Elements("arg").Select(ToArgument).ToArray();
            string watchType = args.Length == 0 ? null : args.Length == 1 ? args[0].DotnetReadType : TupleOf(args.Select(arg => $"{arg.DotnetReadType} {arg.NameUpper}"));
            string methodArg = watchType == null ? $"Action<Exception?>" : $"Action<Exception?, {watchType}>";
            string dotnetMethodName = "Watch" + Prettify(dbusSignalName) + "Async";
            AppendLine($"public ValueTask<IDisposable> {dotnetMethodName}({methodArg} handler, bool emitOnCapturedContext = true, ObserverFlags flags = ObserverFlags.None)");
            if (watchType == null)
            {
                AppendLine($"    => Connection.WatchSignalAsync(Destination, Path, DBusInterfaceName, \"{dbusSignalName}\", handler, this, emitOnCapturedContext, flags);");
            }
            else
            {
                string readMessageName = GetReadMessageMethodName(args, variant: false);
                AppendLine($"    => Connection.WatchSignalAsync(Destination, Path, DBusInterfaceName, \"{dbusSignalName}\", (Message m, object? s) => MessageReader.{readMessageName}(m), handler, this, emitOnCapturedContext, flags);");
            }
        }

        private string GetReadMessageMethodName(Argument[] args, bool variant)
        {
            string mangle = MangleSignatureForMethodName(string.Join("", args.Select(arg => arg.Signature)));
            if (variant)
            {
                mangle = "v_" + mangle;
            }
            string methodName = "Read_" + mangle;
            if (!_messageReadMethods.ContainsKey(methodName))
            {
                _messageReadMethods.Add(methodName, (variant, args));
            }
            return methodName;
        }

        private string GetReadTypeMethodName(string signature)
        {
            string mangle = MangleSignatureForMethodName(signature);
            string methodName = "Read_" + mangle;
            if (!_typeReadMethods.ContainsKey(methodName))
            {
                _typeReadMethods.Add(methodName, signature);

                // Ensure inner types are readable.
                CallForInnerSignatures(signature, sig => CallReadArgumentType(sig));
            }
            return methodName;
        }

        private void CallForInnerSignatures(string signature, Action<string> action)
        {
            SignatureReader reader = new SignatureReader(Encoding.UTF8.GetBytes(signature));
            if (reader.TryRead(out DBusType type, out ReadOnlySpan<byte> innerSignature) && innerSignature.Length > 0)
            {
                reader = new SignatureReader(innerSignature);
                if (type == DBusType.Array)
                {
                    if (!reader.TryRead(out DBusType itemType, out ReadOnlySpan<byte> itemInnerSignature))
                    {
                        ThrowInvalidSignature(signature);
                    }
                    if (itemType == DBusType.DictEntry)
                    {
                        reader = new SignatureReader(itemInnerSignature);
                        if (!reader.TryRead(out DBusType keyType, out ReadOnlySpan<byte> keyInnerSignature))
                        {
                            ThrowInvalidSignature(signature);
                        }
                        if (!reader.TryRead(out DBusType valueType, out ReadOnlySpan<byte> valueInnerSignature))
                        {
                            ThrowInvalidSignature(signature);
                        }
                        action(GetSignature(keyType, keyInnerSignature));
                        action(GetSignature(valueType, valueInnerSignature));
                    }
                    else
                    {
                        action(Encoding.UTF8.GetString(innerSignature));
                    }
                }
                else if (type == DBusType.Struct)
                {
                    while (reader.TryRead(out DBusType fieldType, out ReadOnlySpan<byte> fieldInnerSignature))
                    {
                        action(GetSignature(fieldType, fieldInnerSignature));
                    }
                }
                else
                {
                    ThrowInvalidSignature(signature);
                }
            }
        }

        private string GetWriteTypeMethodName(string signature)
        {
            string mangle = MangleSignatureForMethodName(signature);
            string methodName = "Write_" + mangle;
            if (!_typeWriteMethods.ContainsKey(methodName))
            {
                _typeWriteMethods.Add(methodName, signature);

                // Ensure inner types are writable.
                CallForInnerSignatures(signature, sig => CallWriteArgumentType(sig, "dummy"));
            }
            return methodName;
        }

        private static string MangleSignatureForMethodName(string signature)
        {
            return signature.Replace('{', 'e').Replace('(', 'r').Replace("}", "").Replace(")", "z");
        }

        private static string TupleOf(IEnumerable<string> elements)
            => $"({string.Join(", ", elements)})";

        private void AppendMethod(XElement methodXml)
        {
            // System.Console.WriteLine(methodXml);
            string dbusMethodName = (string)methodXml.Attribute("name");
            var inArgs = methodXml.Elements("arg").Where(arg => (arg.Attribute("direction")?.Value ?? "in") == "in").Select(ToArgument).ToArray();
            var outArgs = methodXml.Elements("arg").Where(arg => arg.Attribute("direction")?.Value == "out").Select(ToArgument).ToArray();
            string dotnetReturnType = outArgs.Length == 0 ? null : outArgs.Length == 1 ? outArgs[0].DotnetReadType : TupleOf(outArgs.Select(arg => $"{arg.DotnetReadType} {arg.NameUpper}"));
            string retType = dotnetReturnType == null ? "Task" : $"Task<{dotnetReturnType}>";

            string args = TupleOf(inArgs.Select(arg => $"{arg.DotnetWriteType} {arg.NameLower}"));

            string dotnetMethodName = Prettify(dbusMethodName) + "Async";
            AppendLine($"public {retType} {dotnetMethodName}{args}");
            StartBlock();
            if (dotnetReturnType != null)
            {
                string readMessageName = GetReadMessageMethodName(outArgs, variant: false);
                AppendLine($"return Connection.CallMethodAsync(CreateMessage(), (Message m, object? s) => MessageReader.{readMessageName}(m), this);");
            }
            else
            {
                AppendLine($"return Connection.CallMethodAsync(CreateMessage());");
            }

            AppendLine("MessageBuffer CreateMessage()");
            StartBlock();
            AppendLine("var writer = Connection.GetMessageWriter();");
            AppendLine("writer.WriteMethodCallHeader(");
            AppendLine($"    destination: Destination,");
            AppendLine($"    path: Path,");
            AppendLine($"    @interface: DBusInterfaceName,");
            if (inArgs.Length > 0)
            {
                string signature = string.Join("", inArgs.Select(a => a.Signature));
                AppendLine($"    signature: \"{signature}\",");
            }
            AppendLine($"    member: \"{dbusMethodName}\");");
            if (inArgs.Length > 0)
            {
            }
            foreach (var inArg in inArgs)
            {
                AppendLine($"{CallWriteArgumentType(inArg.Signature, inArg.NameLower)};");
            }
            AppendLine("return writer.CreateMessage();");
            EndBlock();

            EndBlock();
        }

        private void AppendReadMessageMethod(string name, bool variant, Argument[] args)
        {
            string dotnetReturnType = args.Length == 0 ? null : args.Length == 1 ? args[0].DotnetReadType : TupleOf(args.Select(arg => arg.DotnetReadType));
            AppendLine($"public static {dotnetReturnType} {name}(Message message)");
            StartBlock();
            string signature = string.Join("", args.Select(a => a.Signature));
            AppendLine("var reader = message.GetBodyReader();");
            if (variant)
            {
                AppendLine($"reader.ReadSignature(\"{signature}\"u8);");
            }
            if (args.Length == 1)
            {
                AppendLine($"return {CallReadArgumentType(args[0].Signature)};");
            }
            else
            {
                for (int i = 0; i < args.Length; i++)
                {
                    AppendLine($"var arg{i} = {CallReadArgumentType(args[i].Signature)};");
                }
                AppendLine($"return {TupleOf(args.Select((a, i) => $"arg{i}"))};");
            }
            EndBlock();
        }

        private static string GetDBusTypeEnumValue(DBusType type)
        {
            return type switch
            {
                DBusType.Byte => $"{nameof(DBusType)}.{nameof(DBusType.Byte)}",
                DBusType.Bool => $"{nameof(DBusType)}.{nameof(DBusType.Bool)}",
                DBusType.Int16 => $"{nameof(DBusType)}.{nameof(DBusType.Int16)}",
                DBusType.UInt16 => $"{nameof(DBusType)}.{nameof(DBusType.UInt16)}",
                DBusType.Int32 => $"{nameof(DBusType)}.{nameof(DBusType.Int32)}",
                DBusType.UInt32 => $"{nameof(DBusType)}.{nameof(DBusType.UInt32)}",
                DBusType.Int64 => $"{nameof(DBusType)}.{nameof(DBusType.Int64)}",
                DBusType.UInt64 => $"{nameof(DBusType)}.{nameof(DBusType.UInt64)}",
                DBusType.Double => $"{nameof(DBusType)}.{nameof(DBusType.Double)}",
                DBusType.String => $"{nameof(DBusType)}.{nameof(DBusType.String)}",
                DBusType.ObjectPath => $"{nameof(DBusType)}.{nameof(DBusType.ObjectPath)}",
                DBusType.Signature => $"{nameof(DBusType)}.{nameof(DBusType.Signature)}",
                DBusType.Array => $"{nameof(DBusType)}.{nameof(DBusType.Array)}",
                DBusType.Struct => $"{nameof(DBusType)}.{nameof(DBusType.Struct)}",
                DBusType.Variant => $"{nameof(DBusType)}.{nameof(DBusType.Variant)}",
                DBusType.DictEntry => $"{nameof(DBusType)}.{nameof(DBusType.DictEntry)}",
                DBusType.UnixFd => $"{nameof(DBusType)}.{nameof(DBusType.UnixFd)}",
                _ => throw new ArgumentOutOfRangeException(type.ToString())
            };
        }

        private string CallWriteArgumentType(string signature, string parameterName)
        {
            switch (signature)
            {
                case "y":
                    return $"writer.{nameof(MessageWriter.WriteByte)}({parameterName})";
                case "b":
                    return $"writer.{nameof(MessageWriter.WriteBool)}({parameterName})";
                case "n":
                    return $"writer.{nameof(MessageWriter.WriteInt16)}({parameterName})";
                case "q":
                    return $"writer.{nameof(MessageWriter.WriteUInt16)}({parameterName})";
                case "i":
                    return $"writer.{nameof(MessageWriter.WriteInt32)}({parameterName})";
                case "u":
                    return $"writer.{nameof(MessageWriter.WriteUInt32)}({parameterName})";
                case "x":
                    return $"writer.{nameof(MessageWriter.WriteInt64)}({parameterName})";
                case "t":
                    return $"writer.{nameof(MessageWriter.WriteUInt64)}({parameterName})";
                case "d":
                    return $"writer.{nameof(MessageWriter.WriteDouble)}({parameterName})";
                case "s":
                    return $"writer.{nameof(MessageWriter.WriteString)}({parameterName})";
                case "o":
                    return $"writer.{nameof(MessageWriter.WriteObjectPath)}({parameterName})";
                case "g":
                    return $"writer.{nameof(MessageWriter.WriteSignature)}({parameterName})";
                case "v":
                    return $"writer.{nameof(MessageWriter.WriteVariant)}({parameterName})";
                case "h":
                    return $"writer.{nameof(MessageWriter.WriteHandle)}({parameterName})";

                case "ay":
                    return $"writer.{nameof(MessageWriter.WriteArray)}({parameterName})";
                case "ab":
                    return $"writer.{nameof(MessageWriter.WriteArray)}({parameterName})";
                case "an":
                    return $"writer.{nameof(MessageWriter.WriteArray)}({parameterName})";
                case "aq":
                    return $"writer.{nameof(MessageWriter.WriteArray)}({parameterName})";
                case "ai":
                    return $"writer.{nameof(MessageWriter.WriteArray)}({parameterName})";
                case "au":
                    return $"writer.{nameof(MessageWriter.WriteArray)}({parameterName})";
                case "ax":
                    return $"writer.{nameof(MessageWriter.WriteArray)}({parameterName})";
                case "at":
                    return $"writer.{nameof(MessageWriter.WriteArray)}({parameterName})";
                case "ad":
                    return $"writer.{nameof(MessageWriter.WriteArray)}({parameterName})";
                case "as":
                    return $"writer.{nameof(MessageWriter.WriteArray)}({parameterName})";
                case "ao":
                    return $"writer.{nameof(MessageWriter.WriteArray)}({parameterName})";
                case "ag":
                    return $"writer.{nameof(MessageWriter.WriteArray)}({parameterName})";
                case "av":
                    return $"writer.{nameof(MessageWriter.WriteArray)}({parameterName})";
                case "ah":
                    return $"writer.{nameof(MessageWriter.WriteArray)}({parameterName})";

                case "a{sv}":
                    return $"writer.{nameof(MessageWriter.WriteDictionary)}({parameterName})";
            }

            return $"writer.{GetWriteTypeMethodName(signature)}({parameterName})";
        }

        private string CallReadArgumentType(string signature)
        {
            switch (signature)
            {
                case "y":
                    return $"reader.{nameof(Reader.ReadByte)}()";
                case "b":
                    return $"reader.{nameof(Reader.ReadBool)}()";
                case "n":
                    return $"reader.{nameof(Reader.ReadInt16)}()";
                case "q":
                    return $"reader.{nameof(Reader.ReadUInt16)}()";
                case "i":
                    return $"reader.{nameof(Reader.ReadInt32)}()";
                case "u":
                    return $"reader.{nameof(Reader.ReadUInt32)}()";
                case "x":
                    return $"reader.{nameof(Reader.ReadInt64)}()";
                case "t":
                    return $"reader.{nameof(Reader.ReadUInt64)}()";
                case "d":
                    return $"reader.{nameof(Reader.ReadDouble)}()";
                case "s":
                    return $"reader.{nameof(Reader.ReadString)}()";
                case "o":
                    return $"reader.{nameof(Reader.ReadObjectPath)}()";
                case "g":
                    return $"reader.{nameof(Reader.ReadSignature)}()";
                case "v":
                    return $"reader.{nameof(Reader.ReadVariantValue)}()";
                case "h":
                    return $"reader.{nameof(Reader.ReadHandle)}<{typeof(SafeFileHandle).FullName}>()";

                case "ay":
                    return $"reader.{nameof(Reader.ReadArrayOfByte)}()";
                case "ab":
                    return $"reader.{nameof(Reader.ReadArrayOfBool)}()";
                case "an":
                    return $"reader.{nameof(Reader.ReadArrayOfInt16)}()";
                case "aq":
                    return $"reader.{nameof(Reader.ReadArrayOfUInt16)}()";
                case "ai":
                    return $"reader.{nameof(Reader.ReadArrayOfInt32)}()";
                case "au":
                    return $"reader.{nameof(Reader.ReadArrayOfUInt32)}()";
                case "ax":
                    return $"reader.{nameof(Reader.ReadArrayOfInt64)}()";
                case "at":
                    return $"reader.{nameof(Reader.ReadArrayOfUInt64)}()";
                case "ad":
                    return $"reader.{nameof(Reader.ReadArrayOfDouble)}()";
                case "as":
                    return $"reader.{nameof(Reader.ReadArrayOfString)}()";
                case "ao":
                    return $"reader.{nameof(Reader.ReadArrayOfObjectPath)}()";
                case "ag":
                    return $"reader.{nameof(Reader.ReadArrayOfSignature)}()";
                case "av":
                    return $"reader.{nameof(Reader.ReadArrayOfVariantValue)}()";
                case "ah":
                    return $"reader.{nameof(Reader.ReadArrayOfHandle)}<{typeof(SafeFileHandle).FullName}>()";

                case "a{sv}":
                    return $"reader.{nameof(Reader.ReadDictionaryOfStringToVariantValue)}()";

            }

            return $"reader.{GetReadTypeMethodName(signature)}()";
        }

        private static string GetDotnetReadType(string signature)
            => GetDotnetType(signature, true);

        private static string GetDotnetWriteType(string signature)
            => GetDotnetType(signature, false);

        private static string GetNullableType(string type)
        {
            return type + "?";
        }

        private static string GetDotnetType(string signature, bool readNotWrite)
        {
            SignatureReader reader = new SignatureReader(Encoding.UTF8.GetBytes(signature));
            if (!reader.TryRead(out DBusType type, out ReadOnlySpan<byte> innerSignature))
            {
                ThrowInvalidSignature(signature);
            }
            return GetDotnetType(type, innerSignature, readNotWrite);
        }

        private static string GetDotnetReadType(DBusType type, ReadOnlySpan<byte> innerSignature)
            => GetDotnetType(type, innerSignature, true);

        private static string GetSignature(DBusType type, ReadOnlySpan<byte> innerSignature)
        {
            if (innerSignature.Length == 0)
            {
                return $"{(char)type}";
            }
            else if (type == DBusType.Array)
            {
                return $"a{Encoding.UTF8.GetString(innerSignature)}";
            }
            else if (type == DBusType.Struct)
            {
                return $"({Encoding.UTF8.GetString(innerSignature)})";
            }
            else if (type == DBusType.DictEntry)
            {
                return "{" + Encoding.UTF8.GetString(innerSignature) + "}";
            }
            else
            {
                throw new InvalidOperationException($"Cannot create signature for {type} and {Encoding.UTF8.GetString(innerSignature)}.");
            }
        }

        private static string GetDotnetType(DBusType type, ReadOnlySpan<byte> innerSignature, bool readNotWrite)
        {
            switch (type)
            {
               case DBusType.Byte:
                    return "byte";
               case DBusType.Bool:
                    return "bool";
               case DBusType.Int16:
                  return "short";
               case DBusType.UInt16:
                   return "ushort";
               case DBusType.Int32:
                   return "int";
               case DBusType.UInt32:
                   return "uint";
               case DBusType.Int64:
                   return "long";
               case DBusType.UInt64:
                   return "ulong";
               case DBusType.Double:
                   return "double";
               case DBusType.String:
                    return "string";
               case DBusType.ObjectPath:
                   return "ObjectPath";
               case DBusType.Signature:
                   return "Signature";
               case DBusType.Variant:
                   return "VariantValue";
               case DBusType.UnixFd:
                   return typeof(SafeHandle).FullName;

               case DBusType.Array:
                    {
                        SignatureReader reader = new SignatureReader(innerSignature);
                        if (!reader.TryRead(out DBusType itemtype, out ReadOnlySpan<byte> itemInnerSignature))
                        {
                            ThrowInvalidSignature(GetSignature(type, innerSignature));
                        }
                        bool isDictionary = itemtype == DBusType.DictEntry;
                        if (isDictionary)
                        {
                            reader = new SignatureReader(itemInnerSignature);
                            if (!reader.TryRead(out DBusType keyType, out ReadOnlySpan<byte> keyInnerSignature))
                            {
                                ThrowInvalidSignature(GetSignature(type, innerSignature));
                            }
                            if (!reader.TryRead(out DBusType valueType, out ReadOnlySpan<byte> valueInnerSignature))
                            {
                                ThrowInvalidSignature(GetSignature(type, innerSignature));
                            }
                            string dotnetKeyType = GetDotnetType(keyType, keyInnerSignature, readNotWrite);
                            string dotnetValueType = GetDotnetType(valueType, valueInnerSignature, readNotWrite);
                            return $"Dictionary<{dotnetKeyType}, {dotnetValueType}>";
                        }
                        else
                        {
                            string itemType = GetDotnetType(itemtype, itemInnerSignature, readNotWrite);
                            return $"{itemType}[]";
                        }
                    }
               case DBusType.Struct:
                    {
                        SignatureReader reader = new SignatureReader(innerSignature);
                        StringBuilder sb = new();
                        sb.Append("(");
                        bool first = true;
                        while (reader.TryRead(out DBusType fieldType, out ReadOnlySpan<byte> fieldInnerSignature))
                        {
                            if (!first)
                            {
                                sb.Append(", ");
                            }
                            first = false;
                            sb.Append(GetDotnetType(fieldType, fieldInnerSignature, readNotWrite));
                        }
                        sb.Append(")");
                        return sb.ToString();
                    }
            }

            throw new InvalidOperationException($"Cannot determine .NET type for {type} and {Encoding.UTF8.GetString(innerSignature)}.");
        }

        private Argument ToArgument(XElement argXml, int i)
        {
            return new Argument(i, argXml);
        }

        class Argument
        {
            public Argument(int i, XElement argXml)
            {
                Name = (string)argXml.Attribute("name") ?? $"a{i}";
                Signature = (string)argXml.Attribute("type");
            }

            public string Name { get; }
            public string NameUpper => Prettify(Name, startWithUpper: true);
            public string NameLower => Prettify(Name, startWithUpper: false);
            public string UnderscoreNameLower => "_" + NameLower.TrimStart('@');
            public string Signature { get; }
            public string DotnetReadType => GetDotnetReadType(Signature);
            public string DotnetWriteType => GetDotnetWriteType(Signature);
        }

        private static void ThrowInvalidSignature(string signature)
        {
            throw new InvalidOperationException($"Invalid signature: {signature}");
        }

        private static string Prettify(string name, bool startWithUpper = true)
        {
            if (name == null)
            {
                return null;
            }
            bool upper = startWithUpper;
            var sb = new StringBuilder(name.Length);
            bool first = true;
            foreach (char c in name)
            {
                if (c == '_' || c == '-')
                {
                    upper = true;
                    continue;
                }
                sb.Append(upper ? char.ToUpper(c) : first && !startWithUpper ? char.ToLower(c) : c);
                upper = false;
                first = false;
            }

            name = sb.ToString();
            if (Array.IndexOf(s_keywords, name) != -1)
            {
                return "@" + name;
            }
            return name;
        }

        private static readonly string[] s_keywords = new[] {
            "yield",
            "partial",
            "from",
            "group",
            "join",
            "into",
            "let",
            "by",
            "where",
            "select",
            "get",
            "set",
            "add",
            "remove",
            "orderby",
            "alias",
            "on",
            "equals",
            "ascending",
            "descending",
            "assembly",
            "module",
            "type",
            "field",
            "method",
            "param",
            "property",
            "typevar",
            "global",
            "async",
            "await",
            "when",
            "nameof",
            "_",
            "var",
            "and",
            "or",
            "not",
            "with",
            "init",
            "record",
            "managed",
            "unmanaged",
            "bool",
            "byte",
            "sbyte",
            "short",
            "ushort",
            "int",
            "uint",
            "long",
            "ulong",
            "double",
            "float",
            "decimal",
            "string",
            "char",
            "void",
            "object",
            "typeof",
            "sizeof",
            "null",
            "true",
            "false",
            "if",
            "else",
            "while",
            "for",
            "foreach",
            "do",
            "switch",
            "case",
            "default",
            "lock",
            "try",
            "throw",
            "catch",
            "finally",
            "goto",
            "break",
            "continue",
            "public",
            "private",
            "internal",
            "protected",
            "static",
            "readonly",
            "sealed",
            "const",
            "fixed",
            "stackalloc",
            "volatile",
            "new",
            "override",
            "abstract",
            "virtual",
            "event",
            "extern",
            "ref",
            "out",
            "in",
            "is",
            "as",
            "params",
            "__arglist",
            "__makeref",
            "__reftype",
            "__refvalue",
            "this",
            "base",
            "namespace",
            "using",
            "class",
            "struct",
            "interface",
            "enum",
            "delegate",
            "checked",
            "unchecked",
            "unsafe",
            "operator",
            "implicit",
            "explicit" };
    }
}