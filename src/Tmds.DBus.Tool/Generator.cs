using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml.Linq;

namespace Tmds.DBus.Tool
{
    class GeneratorSettings
    {
        public string Namespace { get; set; } = "DBus";
        public bool NoInternalsVisibleTo = false;
        public Accessibility TypesAccessModifier = Accessibility.NotApplicable;
        public string? GeneratorDescription { get; set; }
    }

    class Generator : IGenerator
    {
        private readonly GeneratorSettings _settings;
        private readonly StringBuilder _sb = new();
        private int _indentation = 0;

        public Generator() : this(new GeneratorSettings())
        {}

        public Generator(GeneratorSettings settings)
        {
            _settings = settings;
        }

        private void StartBlock()
        {
            AppendLine("{");
            _indentation++;
        }

        private void EndBlock()
        {
            _indentation--;
            AppendLine("}");
        }

        private void AppendLine(string line)
        {
            if (line.Length == 0)
            {
                return;
            }
            _sb.Append(' ', _indentation * 4);
            _sb.AppendLine(line);
        }

        public string Generate(IEnumerable<InterfaceDescription> interfaceDescriptions)
        {
            _sb.Clear();
            if (!string.IsNullOrEmpty(_settings.GeneratorDescription))
            {
                AppendLine($"// Generated by {_settings.GeneratorDescription}");
            }
            AppendLine("// <auto-generated/>");
            AppendLine("#nullable enable");

            // Generate using directives
            AppendLine("using System;");
            AppendLine("using System.Collections.Generic;");
            AppendLine("using System.Runtime.CompilerServices;");
            AppendLine("using System.Threading.Tasks;");
            AppendLine("using Tmds.DBus;");

            // Generate assembly attributes
            if (!_settings.NoInternalsVisibleTo)
            {
                AppendLine("[assembly: InternalsVisibleTo(Tmds.DBus.Connection.DynamicAssemblyName)]");
            }

            // Generate namespace
            AppendLine($"namespace {_settings.Namespace}");
            StartBlock();

            foreach (var interfaceDescription in interfaceDescriptions)
            {
                try
                {
                    DBusInterfaceDeclaration(interfaceDescription.Name, interfaceDescription.InterfaceXml);
                }
                catch (Exception ex)
                {
                    throw new InterfaceGenerationException(interfaceDescription, ex);
                }
            }

            EndBlock();

            return _sb.ToString();
        }

        private void DBusInterfaceDeclaration(string name, XElement interfaceXml)
        {
            InterfaceDeclaration(name, interfaceXml);
            if (Properties(interfaceXml).Any())
            {
                PropertiesClassDeclaration(name, ReadableProperties(interfaceXml));
                PropertiesExtensionMethodClassDeclaration(name, interfaceXml);
            }
        }

        private IEnumerable<XElement> Properties(XElement interfaceXml)
            => interfaceXml.Elements("property");

        private IEnumerable<XElement> ReadableProperties(XElement interfaceXml)
            => Properties(interfaceXml).Where(p => p.Attribute("access").Value.StartsWith("read", StringComparison.Ordinal));

        private IEnumerable<XElement> WritableProperties(XElement interfaceXml)
            => Properties(interfaceXml).Where(p => p.Attribute("access").Value.EndsWith("write", StringComparison.Ordinal));

        private void InterfaceDeclaration(string name, XElement interfaceXml)
        {
            string fullName = interfaceXml.Attribute("name").Value;

            var accessibility = GetAccessibilityModifier(_settings.TypesAccessModifier);

            AppendLine($"[DBusInterface(\"{fullName}\")]");
            AppendLine($"{accessibility}interface I{name} : IDBusObject");
            StartBlock();

            bool firstMember = true;
            foreach (var method in interfaceXml.Elements("method"))
            {
                MethodDeclaration(method);
                firstMember = false;
            }

            foreach (var signal in interfaceXml.Elements("signal"))
            {
                SignalDeclaration(signal);
                firstMember = false;
            }

            if (Properties(interfaceXml).Any())
            {
                PropertiesDeclaration(name);
            }

            EndBlock();
        }

        private void PropertiesClassDeclaration(string name, IEnumerable<XElement> propertyXmls)
        {
            var accessibility = GetAccessibilityModifier(_settings.TypesAccessModifier);

            AppendLine("[Dictionary]");
            AppendLine($"{accessibility}class {name}Properties");
            StartBlock();

            foreach (var propertyXml in propertyXmls)
            {
                PropertyToDeclarations(propertyXml);
            }

            EndBlock();
        }

        private void PropertiesExtensionMethodClassDeclaration(string name, XElement interfaceXml)
        {
            var accessibility = GetAccessibilityModifier(_settings.TypesAccessModifier);
            var interfaceName = $"I{name}";

            AppendLine($"{accessibility}static class {name}Extensions");
            StartBlock();

            bool firstMethod = true;
            foreach (var propertyXml in ReadableProperties(interfaceXml))
            {
                PropertyToGet(interfaceName, propertyXml);
                firstMethod = false;
            }

            foreach (var propertyXml in WritableProperties(interfaceXml))
            {
                PropertyToSet(interfaceName, propertyXml);
                firstMethod = false;
            }

            EndBlock();
        }

        private void PropertyToGet(string interfaceName, XElement propertyXml)
        {
            string name = propertyXml.Attribute("name").Value;
            string dbusType = propertyXml.Attribute("type").Value;
            var returnType = ParseType(dbusType);
            var prettyName = Prettify(name);

            AppendLine($"public static Task<{returnType}> Get{prettyName}Async(this {interfaceName} o) => o.GetAsync<{returnType}>(\"{name}\");");
        }

        private void PropertyToSet(string interfaceName, XElement propertyXml)
        {
            string name = propertyXml.Attribute("name").Value;
            string dbusType = propertyXml.Attribute("type").Value;
            var returnType = ParseType(dbusType);
            var prettyName = Prettify(name);

            AppendLine($"public static Task Set{prettyName}Async(this {interfaceName} o, {returnType} val) => o.SetAsync(\"{name}\", val);");
        }

        private void PropertyToDeclarations(XElement propertyXml)
        {
            string name = propertyXml.Attribute("name").Value;
            var fieldName = $"_{name.Replace('-', '_')}";
            string dbusType = propertyXml.Attribute("type").Value;
            string type = ParseType(dbusType);

            AppendLine($"private {type} {fieldName} = default({type});");
            AppendLine($"public {type} {Prettify(name)}");
            StartBlock();
            AppendLine($"get {{ return {fieldName}; }}");
            AppendLine($"set {{ {fieldName} = value; }}");
            EndBlock();
        }

        private void PropertiesDeclaration(string name)
        {
            AppendLine($"Task<T> GetAsync<T>(string prop);");
            AppendLine($"Task<{name}Properties> GetAllAsync();");
            AppendLine($"Task SetAsync(string prop, object val);");
            AppendLine($"Task<IDisposable> WatchPropertiesAsync(Action<PropertyChanges> handler);");
        }

        private void SignalDeclaration(XElement signalXml)
        {
            string name = signalXml.Attribute("name").Value;
            var args = signalXml.Elements("arg").ToList();

            if (args.Count == 0)
            {
                AppendLine($"Task<IDisposable> Watch{name}Async(Action handler, Action<Exception> onError = null);");
            }
            else
            {
                var argTypes = MultyArgsToType(args);
                AppendLine($"Task<IDisposable> Watch{name}Async(Action<{argTypes}> handler, Action<Exception> onError = null);");
            }
        }

        private void MethodDeclaration(XElement methodXml)
        {
            string name = methodXml.Attribute("name").Value;
            var inArgs = methodXml.Elements("arg").Where(arg => (arg.Attribute("direction")?.Value ?? "in") == "in").ToList();
            var outArgs = methodXml.Elements("arg").Where(arg => arg.Attribute("direction")?.Value == "out").ToList();

            string returnType;
            if (outArgs.Count == 0)
            {
                returnType = "Task";
            }
            else
            {
                var outType = MultyArgsToType(outArgs);
                returnType = $"Task<{outType}>";
            }

            var parameters = string.Join(", ", inArgs.Select((arg, idx) => InArgToParameter(arg, idx)));
            AppendLine($"{returnType} {name}Async({parameters});");
        }

        private string MultyArgsToType(List<XElement> args)
        {
            if (args.Count == 0)
                return "";

            if (args.Count == 1)
                return ParseType(args[0].Attribute("type").Value);

            var elementTypes = args.Select(arg =>
            {
                var type = ParseType(arg.Attribute("type").Value);
                var argName = Prettify((string)arg.Attribute("name"), startWithUpper: false);
                return argName != null ? $"{type} {argName}" : type;
            });

            return $"({string.Join(", ", elementTypes)})";
        }

        private string ParseType(string dbusType)
        {
            int index = 0;
            var type = ParseType(dbusType, ref index, null);
            if (index != dbusType.Length)
            {
                throw new InvalidOperationException($"Unable to parse dbus type: {dbusType}");
            }
            return type;
        }

        private string ParseType(string dbusType, ref int index, List<string> elementNames = null)
        {
            char c;
            switch (c = dbusType[index++])
            {
                case 'y': return "byte";
                case 'b': return "bool";
                case 'n': return "short";
                case 'q': return "ushort";
                case 'i': return "int";
                case 'h': return "CloseSafeHandle";
                case 'u': return "uint";
                case 'x': return "long";
                case 't': return "ulong";
                case 'd': return "double";
                case 's': return "string";
                case 'o': return "ObjectPath";
                case 'g': return "Signature";
                case 'f': return "float";
                case 'a': // array
                    if (dbusType[index] == '{')
                    {
                        index++;
                        // 'a{..} // dictionary
                        var keyType = ParseType(dbusType, ref index);
                        var valueType = ParseType(dbusType, ref index);
                        if (dbusType[index++] != '}')
                        {
                            throw new InvalidOperationException($"Unable to parse dbus type: {dbusType}");
                        }
                        return $"IDictionary<{keyType}, {valueType}>";
                    }
                    else
                    {
                        var arrayType = ParseType(dbusType, ref index);
                        return $"{arrayType}[]";
                    }
                case '(': // struct
                    var elements = new List<string>();
                    string type;
                    int idx = 0;
                    while ((type = ParseType(dbusType, ref index)) != null)
                    {
                        var name = elementNames != null && idx < elementNames.Count ? elementNames[idx] : null;
                        idx++;
                        if (name != null)
                        {
                            elements.Add($"{type} {Prettify(name, startWithUpper: false)}");
                        }
                        else
                        {
                            elements.Add(type);
                        }
                    }

                    if (elements.Count < 2)
                    {
                        return $"ValueTuple<{string.Join(", ", elements)}>";
                    }
                    else
                    {
                        return $"({string.Join(", ", elements)})";
                    }
                case 'v': return "object";
                case ')':
                case '}':
                    return null;
                default:
                    throw new NotSupportedException($"Unexpected character '{c}' while parsing dbus type '{dbusType}'");
            }
        }

        private string InArgToParameter(XElement argXml, int index)
        {
            var type = ParseType(argXml.Attribute("type").Value);
            var name = Prettify((string)argXml.Attribute("name"));
            return name != null ? $"{type} {name}" : $"{type} arg{index}";
        }

        private static string GetAccessibilityModifier(Accessibility accessibility)
        {
            return accessibility switch
            {
                Accessibility.Public => "public ",
                Accessibility.Internal => "internal ",
                Accessibility.Private => "private ",
                Accessibility.Protected => "protected ",
                Accessibility.NotApplicable => "",
                _ => ""
            };
        }

        private static string EscapeIdentifier(string identifier)
        {
            if (identifier == null)
                return null;

            // Check if it's a C# keyword that needs escaping
            if (identifier == "interface" || identifier == "event" || identifier == "delegate" ||
                identifier == "abstract" || identifier == "as" || identifier == "base" ||
                identifier == "bool" || identifier == "break" || identifier == "byte" ||
                identifier == "case" || identifier == "catch" || identifier == "char" ||
                identifier == "checked" || identifier == "class" || identifier == "const" ||
                identifier == "continue" || identifier == "decimal" || identifier == "default" ||
                identifier == "do" || identifier == "double" || identifier == "else" ||
                identifier == "enum" || identifier == "explicit" || identifier == "extern" ||
                identifier == "false" || identifier == "finally" || identifier == "fixed" ||
                identifier == "float" || identifier == "for" || identifier == "foreach" ||
                identifier == "goto" || identifier == "if" || identifier == "implicit" ||
                identifier == "in" || identifier == "int" || identifier == "is" ||
                identifier == "lock" || identifier == "long" || identifier == "namespace" ||
                identifier == "new" || identifier == "null" || identifier == "object" ||
                identifier == "operator" || identifier == "out" || identifier == "override" ||
                identifier == "params" || identifier == "private" || identifier == "protected" ||
                identifier == "public" || identifier == "readonly" || identifier == "ref" ||
                identifier == "return" || identifier == "sbyte" || identifier == "sealed" ||
                identifier == "short" || identifier == "sizeof" || identifier == "stackalloc" ||
                identifier == "static" || identifier == "string" || identifier == "struct" ||
                identifier == "switch" || identifier == "this" || identifier == "throw" ||
                identifier == "true" || identifier == "try" || identifier == "typeof" ||
                identifier == "uint" || identifier == "ulong" || identifier == "unchecked" ||
                identifier == "unsafe" || identifier == "ushort" || identifier == "using" ||
                identifier == "virtual" || identifier == "void" || identifier == "volatile" ||
                identifier == "while")
            {
                return "@" + identifier;
            }

            return identifier;
        }

        public static string Prettify(string name, bool startWithUpper = true)
        {
            if (name == null)
            {
                return null;
            }
            bool upper = startWithUpper;
            var sb = new StringBuilder(name.Length);
            bool first = true;
            foreach (char c in name)
            {
                if (c == '_' || c == '-')
                {
                    upper = true;
                    continue;
                }
                sb.Append(upper ? char.ToUpper(c) : first && !startWithUpper ? char.ToLower(c) : c);
                upper = false;
                first = false;
            }
            return EscapeIdentifier(sb.ToString());
        }
    }
}
